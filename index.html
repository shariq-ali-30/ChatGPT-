<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Atlas — Open-Meteo Weather (No API Key)</title>
  <meta name="description" content="Advanced weather app using Open-Meteo (no API key)" />
  <style>
    /* ===========================
       Atlas — Open-Meteo App Styles
       ~ Responsive modern design
       ~ Accessible and minimal
       =========================== */

    :root{
      --bg: #071023;
      --card: rgba(255,255,255,0.03);
      --muted: rgba(255,255,255,0.72);
      --accent: #2dd4bf;
      --accent-2: #60a5fa;
      --radius: 12px;
      --max-w: 1200px;
      --glass: rgba(255,255,255,0.02);
    }

    *{box-sizing:border-box}
    html,body,#app{height:100%}
    body{
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#041028 0%, #081629 100%);
      color:#eaf2fb;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding:28px;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .container{
      width:100%;
      max-width:var(--max-w);
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:22px;
      align-items:start;
    }

    /* Sidebar */
    .sidebar{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:var(--radius);
      padding:18px;
      min-height:620px;
      box-shadow: 0 8px 40px rgba(0,0,0,0.6);
    }
    .brand{display:flex;gap:12px;align-items:center;margin-bottom:6px}
    .logo{
      width:46px;height:46px;border-radius:10px;
      display:grid;place-items:center;font-weight:800;color:#012;background:linear-gradient(135deg,var(--accent),var(--accent-2));
      box-shadow: 0 6px 18px rgba(45,212,191,0.12);
      font-size:20px;
    }
    h1{font-size:18px;margin:0}
    p.lead{margin:2px 0 12px 0;color:var(--muted);font-size:13px}

    .search{display:flex;gap:8px;margin-bottom:12px}
    .search input{
      flex:1;padding:12px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);
      background:transparent;color:inherit;outline:none;font-size:14px;
    }
    .btn{padding:10px 12px;border-radius:10px;border:none;background:var(--accent);color:#012;font-weight:700;cursor:pointer}
    .btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
    .small{font-size:13px;padding:8px 10px;border-radius:8px}

    .help{font-size:12px;color:var(--muted);margin-top:8px}

    .card{background:var(--card);border-radius:12px;padding:12px;margin-top:12px}
    .fav-list .fav-item{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;color:var(--muted);cursor:pointer}
    .fav-item:hover{background:rgba(255,255,255,0.01)}
    .fav-city{font-weight:700}
    .fav-meta{font-size:12px;color:var(--muted)}

    /* Main panel */
    .main{
      background: linear-gradient(180deg, rgba(10,18,30,0.6), rgba(6,10,19,0.6));
      border-radius:var(--radius);
      padding:16px;
      min-height:620px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      position:relative;
      overflow:hidden;
    }

    .bg-blobs{position:absolute;inset:0;z-index:0;pointer-events:none;mix-blend-mode:screen;opacity:0.11}
    .blob{position:absolute;border-radius:50%;filter: blur(80px)}
    .blob.a{width:420px;height:420px;background:linear-gradient(90deg,#2dd4bf,#60a5fa);top:-60px;right:-120px}
    .blob.b{width:260px;height:260px;background:linear-gradient(90deg,#f97316,#f43f5e);bottom:-60px;left:-40px}

    .current-wrap{display:flex;justify-content:space-between;align-items:center;gap:16px;position:relative;z-index:1}
    .current-left{display:flex;gap:14px;align-items:center}
    .icon{width:84px;height:84px;border-radius:12px;background:rgba(255,255,255,0.02);display:grid;place-items:center}
    .location{font-weight:800;font-size:20px}
    .meta{font-size:13px;color:var(--muted)}
    .desc{font-size:14px;color:var(--muted);margin-top:6px}
    .temp{font-size:56px;font-weight:800;line-height:0.9;text-align:right}

    .controls{display:flex;gap:8px;align-items:center}

    .hourly{display:flex;gap:8px;overflow:auto;padding:8px 4px;margin-top:8px}
    .hour{min-width:86px;background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;text-align:center;font-size:13px;color:var(--muted)}
    .hour strong{display:block;margin-top:6px;font-size:14px}

    .daily-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:10px;margin-top:8px}
    .day-card{padding:10px;border-radius:10px;background:rgba(255,255,255,0.01);font-size:13px}

    .details{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:12px}
    .detail{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;text-align:center;font-size:13px}
    .detail strong{display:block;font-size:16px;margin-bottom:6px}

    .placeholder{display:grid;place-items:center;padding:36px;color:var(--muted)}

    /* smaller */
    @media (max-width:980px){
      .container{grid-template-columns:1fr;padding:0 8px}
      .sidebar{order:2}
      .main{order:1}
      .current-wrap{flex-direction:column;align-items:flex-start}
      .temp{text-align:left}
    }

    /* scrollbar */
    .hourly::-webkit-scrollbar{height:8px}
    .hourly::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.06);border-radius:10px}
  </style>
</head>
<body>
  <div id="app">
    <div class="container" role="application" aria-label="Open Meteo Weather App">
      <aside class="sidebar" aria-labelledby="title">
        <div class="brand">
          <div class="logo" aria-hidden="true">A</div>
          <div>
            <h1 id="title">Atlas • Open-Meteo</h1>
            <p class="lead">Free weather — current, hourly (48+), and 7-day. No API key needed.</p>
          </div>
        </div>

        <div class="search" role="search">
          <input id="searchInput" type="search" placeholder="Search city (e.g. London, Tokyo)" aria-label="City name" />
          <button id="searchBtn" class="btn" title="Search">Search</button>
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
          <div style="display:flex;gap:8px">
            <button id="geoBtn" class="btn secondary small" title="Use my location">Use my location</button>
            <button id="unitBtn" class="small" title="Toggle units">°C</button>
          </div>
          <div>
            <button id="saveFav" class="small" title="Save to favorites">☆ Save</button>
          </div>
        </div>

        <div class="help">Tip: Press Enter to search. Save favorites for quick access.</div>

        <div id="suggestions" class="card" style="display:none;margin-top:12px" aria-live="polite"></div>

        <div class="card fav-list" style="margin-top:12px" aria-live="polite">
          <strong>Favorites</strong>
          <div id="favs" style="margin-top:8px"></div>
          <div id="no-favs" class="placeholder" style="display:none">No favorites yet — save a city to reopen it later.</div>
        </div>

        <div class="card" style="margin-top:12px">
          <strong>About</strong>
          <div class="muted" style="margin-top:8px">
            This app uses the Open-Meteo APIs for forecast and the Open-Meteo geocoding service. No API key required.
          </div>
        </div>
      </aside>

      <main class="main" id="mainPanel" aria-live="polite">
        <div class="bg-blobs" aria-hidden="true">
          <div class="blob a"></div>
          <div class="blob b"></div>
        </div>

        <div id="mainContent" style="position:relative;z-index:1">
          <div class="current-wrap">
            <div class="current-left">
              <div class="icon" id="weatherIcon" aria-hidden="true">—</div>
              <div>
                <div class="location" id="locationName">Search a city</div>
                <div class="meta" id="timeMeta">—</div>
                <div class="desc" id="weatherDesc">Get a quick weather snapshot</div>
              </div>
            </div>

            <div class="controls">
              <div style="text-align:right">
                <div class="temp" id="temperature">—</div>
                <div class="meta" id="feelsLike">—</div>
              </div>
            </div>
          </div>

          <div id="loading" class="placeholder" style="display:none">Loading weather…</div>

          <section id="weatherPanels" style="display:none">
            <div class="card" id="overviewCard">
              <div style="display:flex;justify-content:space-between;align-items:center">
                <div>
                  <div style="font-weight:700" id="overviewHeadline">Overview</div>
                  <div class="muted" id="overviewSub">Hourly and 7-day forecast</div>
                </div>
                <div class="row">
                  <div class="chip" id="tempRange">—</div>
                  <div class="chip" id="humidityChip">—</div>
                </div>
              </div>

              <div class="hourly" id="hourlyList" role="list" aria-label="Hourly forecast">
                <!-- hourly items -->
              </div>
            </div>

            <div class="card" id="dailyCard">
              <strong>7-Day Forecast</strong>
              <div class="daily-grid" id="dailyGrid" aria-label="Daily forecast">
                <!-- daily cards -->
              </div>
            </div>

            <div class="card" id="detailsCard">
              <strong>Details</strong>
              <div class="details" id="detailsGrid">
                <div class="detail">
                  <strong id="windSpeed">—</strong>
                  Wind
                </div>
                <div class="detail">
                  <strong id="pressure">—</strong>
                  Pressure
                </div>
                <div class="detail">
                  <strong id="uvIndex">—</strong>
                  UV Index
                </div>
              </div>
            </div>

            <div class="credits" style="margin-top:12px">Powered by Open-Meteo • Geocoding by Open-Meteo</div>
          </section>
        </div>
      </main>
    </div>
  </div>

  <script>
    /*
      Atlas — Open-Meteo Weather App (Single-file)
      Features:
        - Geocoding via geocoding-api.open-meteo.com (no API key)
        - Forecast via api.open-meteo.com (no API key)
        - Current weather, hourly, daily
        - Units toggle (metric/imperial) handled by API params
        - Favorites stored in localStorage
        - Geolocation support
        - Graceful error handling
    */

    // ====== CONFIG / Endpoints ======
    const GEOCODE_BASE = 'https://geocoding-api.open-meteo.com/v1/search';
    const FORECAST_BASE = 'https://api.open-meteo.com/v1/forecast';

    // We'll request these hourly & daily variables:
    const HOURLY_VARS = [
      'temperature_2m',
      'apparent_temperature',
      'precipitation',
      'weathercode',
      'windspeed_10m',
      'winddirection_10m',
      'relativehumidity_2m'
    ];
    const DAILY_VARS = [
      'temperature_2m_max',
      'temperature_2m_min',
      'apparent_temperature_max',
      'apparent_temperature_min',
      'precipitation_sum',
      'weathercode'
    ];

    // Short helper to build query strings
    function qs(obj){
      return Object.keys(obj).map(k => encodeURIComponent(k) + '=' + encodeURIComponent(obj[k])).join('&');
    }

    // ====== DOM nodes ======
    const searchInput = document.getElementById('searchInput');
    const searchBtn = document.getElementById('searchBtn');
    const geoBtn = document.getElementById('geoBtn');
    const unitBtn = document.getElementById('unitBtn');
    const saveFavBtn = document.getElementById('saveFav');
    const favsContainer = document.getElementById('favs');
    const noFavs = document.getElementById('no-favs');
    const suggestionsBox = document.getElementById('suggestions');

    const loadingEl = document.getElementById('loading');
    const mainPanels = document.getElementById('weatherPanels');
    const weatherIcon = document.getElementById('weatherIcon');
    const locationName = document.getElementById('locationName');
    const timeMeta = document.getElementById('timeMeta');
    const weatherDesc = document.getElementById('weatherDesc');
    const temperatureEl = document.getElementById('temperature');
    const feelsLikeEl = document.getElementById('feelsLike');

    const hourlyList = document.getElementById('hourlyList');
    const dailyGrid = document.getElementById('dailyGrid');
    const tempRange = document.getElementById('tempRange');
    const humidityChip = document.getElementById('humidityChip');

    const windSpeed = document.getElementById('windSpeed');
    const pressure = document.getElementById('pressure');
    const uvIndex = document.getElementById('uvIndex');

    // ====== App state ======
    const STATE = {
      units: localStorage.getItem('atlas_units') || 'metric', // 'metric' or 'imperial'
      favorites: JSON.parse(localStorage.getItem('atlas_favs') || '[]'),
      last: null, // last loaded forecast object
      debounce: null,
      searchCache: {} // cache geocoding responses
    };

    // Initialize UI
    (function init(){
      renderUnits();
      loadFavorites();
      attachEvents();
      // If have favorites, load first one to show something
      if(STATE.favorites.length > 0){
        fetchWeatherForCity(STATE.favorites[0].name, STATE.favorites[0].country).catch(()=>{});
      }
    })();

    // ====== Event wiring ======
    function attachEvents(){
      searchBtn.addEventListener('click', onSearchClick);
      searchInput.addEventListener('keydown', e => {
        if(e.key === 'Enter') onSearchClick();
        // live suggestions (debounced)
        if(e.key.length === 1 || e.key === 'Backspace' || e.key === 'Delete') {
          debouncedSuggestions(searchInput.value.trim());
        }
      });
      geoBtn.addEventListener('click', tryGeo);
      unitBtn.addEventListener('click', toggleUnits);
      saveFavBtn.addEventListener('click', saveCurrentToFavs);

      favsContainer.addEventListener('click', e=>{
        const t = e.target.closest('.fav-item');
        if(!t) return;
        const city = t.dataset.city;
        const country = t.dataset.country || '';
        fetchWeatherForCity(city, country).catch(()=>{});
      });

      favsContainer.addEventListener('click', e=>{
        if(e.target.classList.contains('remove-fav')){
          e.stopPropagation();
          const parent = e.target.closest('.fav-item');
          if(!parent) return;
          const name = parent.dataset.city;
          removeFromFavs(name);
        }
      });

      suggestionsBox.addEventListener('click', e=>{
        const item = e.target.closest('.s-item');
        if(!item) return;
        const city = item.dataset.city;
        const country = item.dataset.country || '';
        searchInput.value = city + (country ? ', ' + country : '');
        suggestionsBox.style.display = 'none';
        fetchWeatherForCity(city, country).catch(()=>{});
      });

      document.addEventListener('click', e=>{
        if(!e.target.closest('#searchInput') && !e.target.closest('#suggestions')){
          suggestionsBox.style.display = 'none';
        }
      });
    }

    // ====== Units handling ======
    function toggleUnits(){
      STATE.units = STATE.units === 'metric' ? 'imperial' : 'metric';
      localStorage.setItem('atlas_units', STATE.units);
      renderUnits();
      if(STATE.last && STATE.last.coords){
        // re-fetch with new units
        fetchWeatherByCoords(STATE.last.coords.lat, STATE.last.coords.lon, STATE.last.name, STATE.last.country).catch(()=>{});
      }
    }
    function renderUnits(){
      unitBtn.textContent = STATE.units === 'metric' ? '°C' : '°F';
    }

    // ====== Favorites ======
    function loadFavorites(){
      const favs = STATE.favorites || [];
      favsContainer.innerHTML = '';
      if(favs.length === 0){
        noFavs.style.display = 'block';
        return;
      }
      noFavs.style.display = 'none';
      favs.forEach(f=>{
        const item = document.createElement('div');
        item.className = 'fav-item';
        item.dataset.city = f.name;
        item.dataset.country = f.country || '';
        item.innerHTML = `
          <div>
            <div class="fav-city">${escapeHtml(f.name)}</div>
            <div class="fav-meta">${escapeHtml(f.country || '')}</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <button class="remove-fav" aria-label="Remove favorite">✕</button>
          </div>
        `;
        favsContainer.appendChild(item);
      });
    }
    function saveCurrentToFavs(){
      if(!STATE.last || !STATE.last.name) return alert('No city loaded to save.');
      const exists = STATE.favorites.find(f => f.name.toLowerCase() === STATE.last.name.toLowerCase());
      if(exists) return alert('Already in favorites.');
      const entry = { name: STATE.last.name, country: STATE.last.country || '' };
      STATE.favorites.unshift(entry);
      localStorage.setItem('atlas_favs', JSON.stringify(STATE.favorites));
      loadFavorites();
      alert('Saved to favorites.');
    }
    function removeFromFavs(name){
      STATE.favorites = STATE.favorites.filter(f => f.name.toLowerCase() !== name.toLowerCase());
      localStorage.setItem('atlas_favs', JSON.stringify(STATE.favorites));
      loadFavorites();
    }
   // ====== Suggestions (very light) ======
    function debouncedSuggestions(q){
      clearTimeout(STATE.debounce);
      if(!q){ suggestionsBox.style.display = 'none'; return; }
      STATE.debounce = setTimeout(()=>showSuggestions(q), 350);
    }
    function showSuggestions(q){
      const res = [];
      // local favorites
      STATE.favorites.forEach(f=>{
        if(f.name.toLowerCase().includes(q.toLowerCase())) res.push({city:f.name, country:f.country || ''});
      });
      // cached searches
      for(const k in STATE.searchCache){
        if(k.toLowerCase().includes(q.toLowerCase())){
          const c = STATE.searchCache[k];
          res.push({city:k, country:c.country || ''});
        }
      }
      if(res.length === 0){
        suggestionsBox.innerHTML = `<div class="s-item" data-city="${escapeHtml(q)}" data-country="">Search "${escapeHtml(q)}"</div>`;
      } else {
        suggestionsBox.innerHTML = res.map(r=>`<div class="s-item" data-city="${escapeHtml(r.city)}" data-country="${escapeHtml(r.country)}">${escapeHtml(r.city)} <span class="muted">${r.country||''}</span></div>`).join('');
      }
      suggestionsBox.style.display = 'block';
    }

    // ====== Search flow: city -> geocode -> forecast ======
    async function onSearchClick(){
      const q = searchInput.value.trim();
      if(!q) return alert('Please enter a city or location.');
      const parts = q.split(',').map(p=>p.trim()).filter(Boolean);
      const city = parts[0];
      const country = parts[1] || '';
      await fetchWeatherForCity(city, country);
    }

    async function fetchWeatherForCity(city, country=''){
      showLoading();
      try{
        const cacheKey = (city + (country ? ','+country : '')).toLowerCase();
        let entry;
        if(STATE.searchCache[cacheKey]){
          entry = STATE.searchCache[cacheKey];
        } else {
          // call geocoding
          const geourl = `${GEOCODE_BASE}?${qs({name: city, count: 5, language: 'en', format: 'json'})}`;
          const r = await fetch(geourl);
          if(!r.ok) throw new Error('Geocoding failed');
          const data = await r.json();
          if(!data.results || data.results.length === 0){
            throw new Error('No results for that city.');
          }
          // prefer exact match including country if provided, else first result
          let chosen = data.results[0];
          if(country){
            const match = data.results.find(x => (x.country && x.country.toLowerCase() === country.toLowerCase()) || (x.country_code && x.country_code.toLowerCase() === country.toLowerCase()));
            if(match) chosen = match;
          }
          entry = {
            name: chosen.name,
            country: chosen.country || chosen.country_code || '',
            lat: chosen.latitude,
            lon: chosen.longitude,
            timezone: chosen.timezone || 'auto'
          };
          STATE.searchCache[cacheKey] = entry;
        }
        await fetchWeatherByCoords(entry.lat, entry.lon, entry.name, entry.country, entry.timezone);
      } catch(err){
        console.error(err);
        alert('Error: ' + (err.message || err));
        hideLoading();
      }
    }

    async function tryGeo(){
      if(!navigator.geolocation){
        alert('Geolocation not supported in this browser.');
        return;
      }
      showLoading();
      navigator.geolocation.getCurrentPosition(async pos=>{
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;
        // attempt reverse lookup to get place name
        try{
          // Open-Meteo's geocoding also supports lat/lon lookup using nearby parameter via search? We'll call the geocoding endpoint with 'name' fallback by nearby search through reverse style (use their 'reverse' capability if available).
          // Simpler: call geocoding with a small name search using latitude & longitude by selecting first nearby by distance: the geocoding API supports 'count' and searching by ?we will call 'geocoding-api.open-meteo.com/v1/reverse?latitude=..&longitude=..'
          const reverseUrl = `https://geocoding-api.open-meteo.com/v1/reverse?latitude=${lat}&longitude=${lon}&count=1&language=en`;
          const r = await fetch(reverseUrl);
          let name='Your Location', country='';
          if(r.ok){
            const j = await r.json();
            if(j.results && j.results.length>0){
              name = j.results[0].name || name;
              country = j.results[0].country || j.results[0].country_code || country;
            }
          }
          await fetchWeatherByCoords(lat, lon, name, country);
        } catch(err){
          console.error(err);
          alert('Failed to get location name, still fetching coordinates.');
          await fetchWeatherByCoords(lat, lon, 'Your Location', '');
        }
      }, err=>{
        hideLoading();
        alert('Geolocation error: ' + err.message);
      }, { enableHighAccuracy: true, timeout: 10000 });
    }

    // ====== Fetch forecast by coords ======
    async function fetchWeatherByCoords(lat, lon, name='Unknown', country='', timezone='auto'){
      showLoading();
      try{
        const units = STATE.units; // 'metric' or 'imperial'
        // open-meteo query params:
        // - hourly: list of variables
        // - daily: list
        // - current_weather=true gives current temperature + wind + weathercode
        // - temperature_unit and windspeed_unit depend on units
        const params = {
          latitude: lat,
          longitude: lon,
          timezone: timezone || 'auto',
          hourly: HOURLY_VARS.join(','),
          daily: DAILY_VARS.join(','),
          current_weather: true,
          past_days: 0
        };
        // units mapping (Open-Meteo supports temperature_unit and windspeed_unit)
        if(units === 'imperial'){
          params.temperature_unit = 'fahrenheit';
          params.windspeed_unit = 'mph';
          // precipitation and pressure units are standard (mm, hPa), we will format where needed
        } else {
          params.temperature_unit = 'celsius';
          params.windspeed_unit = 'ms';
        }

        const url = `${FORECAST_BASE}?${qs(params)}`;
        const r = await fetch(url);
        if(!r.ok) throw new Error('Forecast request failed');
        const data = await r.json();

        // Build a normalized state object
        const state = {
          name,
          country,
          coords: { lat, lon },
          timezone: data.timezone || timezone,
          units,
          fetchedAt: Date.now(),
          data
        };
        STATE.last = state;
        // store in searchCache for suggestions
        const cacheKey = (name + (country ? ','+country : '')).toLowerCase();
        STATE.searchCache[cacheKey] = { coords: { lat, lon }, country };

        renderWeather(state);
      } catch(err){
        console.error(err);
        alert('Failed to fetch weather: ' + (err.message || err));
      } finally{
        hideLoading();
      }
    }

    // ====== Render functions ======
    function showLoading(){
      loadingEl.style.display = 'block';
      mainPanels.style.display = 'none';
    }
    function hideLoading(){
      loadingEl.style.display = 'none';
    }

    function renderWeather(state){
      if(!state || !state.data) return;
      mainPanels.style.display = 'block';
      const data = state.data;
      const cur = data.current_weather || {};
      // display location
      locationName.textContent = `${state.name}${state.country ? ', ' + state.country : ''}`;
      // time: use current weather time if available
      if(cur.time){
        const when = new Date(cur.time + (':00')); // cur.time is ISO-like "2023-09-01T12:34"
        // ensure valid date
        const d = new Date(cur.time);
        timeMeta.textContent = isNaN(d.getTime()) ? (new Date()).toLocaleString() : d.toLocaleString();
      } else {
        timeMeta.textContent = new Date().toLocaleString();
      }

      // Weather description from weathercode (Open-Meteo provides weathercode int)
      const wcode = cur.weathercode ?? (data.hourly?.weathercode?.[0]);
      const wdesc = weatherCodeToText(wcode);
      weatherDesc.textContent = capitalize(wdesc);

      // Icon / simple svg symbol depending on code
      weatherIcon.innerHTML = iconForWeatherCode(wcode);

      // Temps
      const tempUnit = state.units === 'metric' ? '°C' : '°F';
      const curTemp = cur.temperature ?? data.hourly?.temperature_2m?.[0];
      const feels = inferFeelsLike(state, cur);
      temperatureEl.textContent = curTemp != null ? `${Math.round(curTemp)}${tempUnit}` : '—';
      feelsLikeEl.textContent = feels != null ? `Feels like ${Math.round(feels)}${tempUnit}` : '';

      // Overview chips: high/low over next 7 days
      if(data.daily && data.daily.time){
        const highs = data.daily.temperature_2m_max || [];
        const lows = data.daily.temperature_2m_min || [];
        const hi = highs.length ? Math.round(Math.max(...highs)) : '—';
        const lo = lows.length ? Math.round(Math.min(...lows)) : '—';
        tempRange.textContent = `H ${hi}${tempUnit} • L ${lo}${tempUnit}`;
      } else {
        tempRange.textContent = '—';
      }

      // humidity chip (take from hourly nearest)
      const hum = nearestHourlyValue(data.hourly, 'relativehumidity_2m', cur.time);
      humidityChip.textContent = hum != null ? `Humidity ${Math.round(hum)}%` : 'Humidity —';

      // Hourly: show next 48 hours (if available)
      hourlyList.innerHTML = '';
      if(data.hourly && data.hourly.time){
        // find starting index aligned with current time
        const times = data.hourly.time;
        const t0 = cur.time || times[0];
        const startIdx = Math.max(0, times.findIndex(t => t === t0));
        const slice = times.slice(startIdx, startIdx + 48);
        slice.forEach((t, idx)=>{
          const absIdx = startIdx + idx;
          const temp = data.hourly.temperature_2m?.[absIdx];
          const hcode = data.hourly.weathercode?.[absIdx];
          const precip = data.hourly.precipitation?.[absIdx] ?? 0;
          const hourText = toLocalHour(t, state.timezone);
          const el = document.createElement('div');
          el.className = 'hour';
          el.innerHTML = `
            <div class="muted">${hourText}</div>
            <div style="margin-top:6px">${smallIconSVG(hcode)}</div>
            <strong>${temp != null ? Math.round(temp)+tempUnit : '—'}</strong>
            <div class="muted" style="font-size:12px;margin-top:6px">${precip ? (precip + (state.units==='metric' ? ' mm' : ' mm')) : ''}</div>
          `;
hourlyList.appendChild(el);
        });
      } else {
        hourlyList.innerHTML = '<div class="placeholder">Hourly data not available.</div>';
      }

      // Daily grid (7 days)
      dailyGrid.innerHTML = '';
      if(data.daily && data.daily.time){
        for(let i=0;i<Math.min(data.daily.time.length, 7); i++){
          const day = data.daily.time[i];
          const hi = data.daily.temperature_2m_max?.[i];
          const lo = data.daily.temperature_2m_min?.[i];
          const code = data.daily.weathercode?.[i];
          const dow = new Date(day).toLocaleDateString([], {weekday:'short', month:'short', day:'numeric'});
          const el = document.createElement('div');
          el.className = 'day-card';
          el.innerHTML = `
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div style="font-weight:700">${dow}</div>
              <div>${smallIconSVG(code)}</div>
            </div>
            <div class="muted" style="margin-top:8px">${capitalize(weatherCodeToText(code))}</div>
            <div style="margin-top:8px;display:flex;justify-content:space-between;gap:8px">
              <div><strong>${hi != null ? Math.round(hi) + tempUnit : '—'}</strong><div class="muted" style="font-size:12px">High</div></div>
              <div><strong>${lo != null ? Math.round(lo) + tempUnit : '—'}</strong><div class="muted" style="font-size:12px">Low</div></div>
            </div>
          `;
          dailyGrid.appendChild(el);
        }
      } else {
        dailyGrid.innerHTML = '<div class="placeholder">Daily data not available.</div>';
      }

      // Details
      windSpeed.textContent = cur.windspeed != null ? `${Math.round(cur.windspeed)} ${state.units === 'metric' ? 'm/s' : 'mph'}` : '—';
      // Open-Meteo does not return pressure in current_weather; skip or display NA
      pressure.textContent = (nearestHourlyValue(state.data.hourly, 'pressure_msl', cur.time) != null) ? `${Math.round(nearestHourlyValue(state.data.hourly, 'pressure_msl', cur.time))} hPa` : '—';
      uvIndex.textContent = (nearestHourlyValue(state.data.hourly, 'uv_index', cur.time) != null) ? `${nearestHourlyValue(state.data.hourly, 'uv_index', cur.time)}` : '—';

      applyWeatherBackground(wcode);

      // Save last to localStorage (light)
      try{ localStorage.setItem('atlas_last', JSON.stringify(state)); } catch(e){}

    }

    // ====== Helpers & Utilities ======
    function escapeHtml(s){
      return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
    }
    function capitalize(s){ return s ? s.charAt(0).toUpperCase() + s.slice(1) : '' }

    // returns nearest hourly value from a named series to a given time string
    function nearestHourlyValue(hourly, varname, targetTime){
      if(!hourly || !hourly.time || !hourly[varname]) return null;
      const idx = hourly.time.findIndex(t => t === targetTime);
      if(idx !== -1) return hourly[varname][idx];
      // fallback: take first value
      return hourly[varname][0];
    }

    // infer feels-like (prefer apparent_temperature if present)
    function inferFeelsLike(state, cur){
      try{
        if(state.data.hourly && state.data.hourly.apparent_temperature){
          const idx = state.data.hourly.time.findIndex(t => t === cur.time);
          if(idx !== -1) return state.data.hourly.apparent_temperature[idx];
          return state.data.hourly.apparent_temperature[0];
        }
        return null;
      } catch(e){ return null; }
    }

    // time formatting helpers (Open-Meteo returns ISO-like "2023-09-01T12:00")
    function toLocalHour(timestr, tz){
      try{
        const d = new Date(timestr);
        return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
      } catch(e){
        return timestr;
      }
    }

    // ====== Weather code mapping (Open-Meteo weathercode -> text)
    // Source: WMO weather interpretation codes used by Open-Meteo
    function weatherCodeToText(code){
      // codes from https://open-meteo.com/en/docs#api_form
      const map = {
        0: 'Clear sky',
        1: 'Mainly clear',
        2: 'Partly cloudy',
        3: 'Overcast',
        45: 'Fog',
        48: 'Depositing rime fog',
        51: 'Light drizzle',
        53: 'Moderate drizzle',
        55: 'Dense drizzle',
        56: 'Light freezing drizzle',
        57: 'Dense freezing drizzle',
        61: 'Slight rain',
        63: 'Moderate rain',
        65: 'Heavy rain',
        66: 'Light freezing rain',
        67: 'Heavy freezing rain',
        71: 'Slight snow fall',
        73: 'Moderate snow fall',
        75: 'Heavy snow fall',
        77: 'Snow grains',
        80: 'Slight rain showers',
        81: 'Moderate rain showers',
        82: 'Violent rain showers',
        85: 'Slight snow showers',
        86: 'Heavy snow showers',
        95: 'Thunderstorm',
        96: 'Thunderstorm with slight hail',
        99: 'Thunderstorm with heavy hail'
      };
      return map[code] || 'Unknown';
    }

    // tiny SVG icons for display (keeps app local & fast)
    function smallIconSVG(code){
      // return small inline SVG markup representing sun/cloud/rain/snow/thunder
      const c = Number(code);
      if(c === 0 || c === 1) return sunSVG(40);
      if(c === 2 || c === 3 || (c >= 45 && c <= 48)) return cloudSVG(40);
      if((c >= 51 && c <= 67) || (c >= 80 && c <= 82)) return rainSVG(40);
      if((c >= 71 && c <= 86) || c === 77) return snowSVG(40);
      if(c >= 95) return thunderSVG(40);
      return sunSVG(40);
    }
    function iconForWeatherCode(code){
      return `<div style="display:grid;place-items:center;width:84px;height:84px">${smallIconSVG(code)}</div>`;
    }

    function sunSVG(size=48){
      return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
        <circle cx="12" cy="12" r="4" stroke="currentColor" stroke-width="1.6" fill="rgba(255,205,86,0.12)"/>
        <g stroke="currentColor" stroke-width="1.2" stroke-linecap="round">
          <path d="M12 1v2"/>
          <path d="M12 21v2"/>
          <path d="M4.2 4.2l1.4 1.4"/>
          <path d="M18.4 18.4l1.4 1.4"/>
          <path d="M1 12h2"/>
          <path d="M21 12h2"/>
          <path d="M4.2 19.8l1.4-1.4"/>
          <path d="M18.4 5.6l1.4-1.4"/>
        </g>
      </svg>`;
    }
    function cloudSVG(size=48){
      return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
        <path d="M20 17.5A4.5 4.5 0 0015.5 13H14a4 4 0 10-7.9 1.2A3.5 3.5 0 006.5 19H19a1 1 0 001-1.5z" fill="rgba(200,215,230,0.06)" stroke="currentColor" stroke-width="1.2"/>
      </svg>`;
    }
    function rainSVG(size=48){
      return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
        <path d="M20 17.5A4.5 4.5 0 0015.5 13H14a4 4 0 10-7.9 1.2A3.5 3.5 0 006.5 19H19" fill="rgba(110,150,220,0.06)" stroke="currentColor" stroke-width="1.2"/>
        <path d="M8 20l1.2-2M12 20l1.2-2M16 20l1.2-2" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"/>
      </svg>`;
    }
    function snowSVG(size=48){
      return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
        <path d="M20 17.5A4.5 4.5 0 0015.5 13H14a4 4 0 10-7.9 1.2A3.5 3.5 0 006.5 19H19" fill="rgba(220,240,255,0.04)" stroke="currentColor" stroke-width="1.2"/>
        <g stroke="currentColor" stroke-width="1.2" stroke-linecap="round">
          <path d="M8 20l0.8-0.6M8 18.6l0.8 0.6M7.2 19.2h1.6"/>
          <path d="M12 20l0.8-0.6M12 18.6l0.8 0.6M11.2 19.2h1.6"/>
          <path d="M16 20l0.8-0.6M16 18.6l0.8 0.6M15.2 19.2h1.6"/>
        </g>
      </svg>`;
    }
    function thunderSVG(size=48){
      return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
        <path d="M20 16.5A4.5 4.5 0 0015.5 12H14a4 4 0 10-7.9 1.2A3.5 3.5 0 006.5 18H19" fill="rgba(255,220,120,0.04)" stroke="currentColor" stroke-width="1.2"/>
        <path d="M13 10l-3 6h4l-3 6" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>`;
    }

    // background vibe
    function applyWeatherBackground(code){
      const blobA = document.querySelector('.blob.a');
      const blobB = document.querySelector('.blob.b');
      const c = Number(code);
      if(c >= 51 && c <= 67 || (c >= 80 && c <= 82) || (c >= 95)) {
        // rainy / thunder
        blobA.style.background = 'linear-gradient(90deg,#3b82f6,#6366f1)';
        blobB.style.background = 'linear-gradient(90deg,#0ea5e9,#06b6d4)';
      } else if(c >= 71 && c <= 86 || c === 77) {
        // snow
        blobA.style.background = 'linear-gradient(90deg,#93c5fd,#e0f2fe)';
        blobB.style.background = 'linear-gradient(90deg,#bae6fd,#bfdbfe)';
      } else if(c === 0 || c === 1) {
        // clear
        blobA.style.background = 'linear-gradient(90deg,#f59e0b,#f97316)';
        blobB.style.background = 'linear-gradient(90deg,#f97316,#fb7185)';
      } else {
        // cloud/others
        blobA.style.background = 'linear-gradient(90deg,#2dd4bf,#60a5fa)';
        blobB.style.background = 'linear-gradient(90deg,#94a3b8,#64748b)';
      }
    }

    // ====== Utility: convert ISO-ish time to Date reliably
    // Open-Meteo returns times like "2023-09-01T12:00"
    // Safari sometimes needs "2023-09-01T12:00:00" — we add seconds if missing.
    function safeDate(s){
      if(!s) return new Date();
      return new Date(s.length === 16 ? s + ':00' : s);
    }

    // ====== Misc helpers ======
    function toLocalHourISO(s, tz){
      try{
        const d = safeDate(s);
        return d.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'});
      } catch(e){
        return s;
      }
    }

    // alias used earlier
    function toLocalHour(timestr, tz){ return toLocalHourISO(timestr, tz); }

    // ====== End of app code ======
  </script>
</body>
</html>